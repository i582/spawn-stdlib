module testing

import fs
import strings
import strconv
import term
import backtrace

// COVERAGE_MAPPING is a string that contains the mapping between the basic block
// index and the source code location.
//
// Actual value of this constant is generated by the compiler and embedded into the
// binary when the coverage is enabled.
const COVERAGE_MAPPING = ''

// COUNT_BASIC_BLOCKS is the number of basic blocks in the code.
// [`spawn_coverage`] contains at most this number of elements.
//
// Actual value of this constant is generated by the compiler.
const COUNT_BASIC_BLOCKS = 0

var (
	// spawn_coverage is an array that stores the coverage information.
	// Each index corresponds to a separate basic block in code.
	// This array can store at most [`COUNT_BASIC_BLOCKS`] elements.
	//
	// Basic blocks are identified by the compiler and are unique.
	spawn_coverage = []i32{len: COUNT_BASIC_BLOCKS}
)

// mark_coverage sets the coverage for the given id to 1.
// This means that the code block was executed at least once.
// Used in `set` coverage mode.
#[inline]
#[skip_coverage]
pub fn mark_coverage(id i32) {
	// SAFETY: `id` is always a valid index generated by the compiler
	unsafe { spawn_coverage.fast_set(id, 1) }
}

// inc_coverage increments the coverage for the given id by 1.
// This means that the code block was executed again.
// Used in `count` coverage mode.
#[inline]
#[skip_coverage]
pub fn inc_coverage(id i32) {
	// SAFETY: `id` is always a valid index generated by the compiler
	unsafe { spawn_coverage.fast_set(id, spawn_coverage[id] + 1) }
}

// CoverageBlock represents a single basic block in the code.
struct CoverageBlock {
	id         i32
	file       string
	func       string
	start_line i32
	start_col  i32
	end_line   i32
	end_col    i32
}

// coverage_rate returns the coverage rate of the code.
// It is calculated as the number of covered basic blocks divided by the
// total number of basic blocks.
pub fn coverage_rate() -> f64 {
	if COUNT_BASIC_BLOCKS == 0 {
		return 0.0
	}

	mut covered := 0
	for i in 0 .. COUNT_BASIC_BLOCKS {
		sample := spawn_coverage[i]
		if sample > 0 {
			covered += 1
		}
	}

	return (covered as f64) / (COUNT_BASIC_BLOCKS as f64)
}

// print_coverage_rate prints the coverage rate of the code.
// Example:
// ```
// coverage: 80.00%
// ```
pub fn print_coverage_rate() {
	rate := coverage_rate() * 100
	rate_percent := strconv.float_to_str(rate, 2, 512)
	println('coverage: ${rate_percent}%')
}

// CoverageFileResult represents the overall coverage
// statistic for a single file.
pub struct CoverageFileResult {
	// path is the path to the file.
	path string
	// funcs is the coverage rate of the functions in the file.
	funcs f64
	// blocks is the coverage rate of the blocks in the file.
	blocks f64
}

// CoverageResult represents the overall coverage statistic.
pub struct CoverageResult {
	// testing_path is the path to the directory from which the tests were run.
	testing_path string
	// files is the coverage information for each file.
	files map[string]CoverageFileResult = map[string]CoverageFileResult{}
}

// from analyzes the coverage information and returns the overall coverage statistic.
pub fn CoverageResult.from(testing_path string, c Coverage) -> CoverageResult {
	mut res := CoverageResult{ testing_path: testing_path }

	for file in c.per_file {
		if !file.path.starts_with(testing_path) {
			// not module file, can be ignored
			continue
		}

		count_blocks := file.blocks.len
		count_funcs := file.per_function.len

		if count_funcs == 0 {
			// file has no functions, skip it
			continue
		}

		mut count_covered_blocks := 0

		// block considered covered if it was executed at least once
		for block in file.blocks {
			cov := spawn_coverage[block.id]
			if cov > 0 {
				// block was executed, mark it as covered
				count_covered_blocks++
			}
		}

		mut count_covered_funcs := 0

		// function considered covered if any of its blocks are covered
		// this is a simplification, but it should be good enough for now
		outer: for func in file.per_function {
			for block in func.blocks {
				cov := spawn_coverage[block.id]
				if cov > 0 {
					// found a covered block, mark the function as covered
					count_covered_funcs++
					continue outer
				}
			}
		}

		res.files[file.path] = CoverageFileResult{
			path: file.path
			funcs: (count_covered_funcs as f64) / (count_funcs as f64)
			blocks: (count_covered_blocks as f64) / (count_blocks as f64)
		}
	}

	return res
}

// print prints the coverage information to the terminal.
pub fn (r CoverageResult) print() {
	mut max_width := 0 as usize
	for file in r.files {
		path := r.format_path(file.path)
		if path.len > max_width {
			max_width = path.len
		}
	}

	if max_width < 4 {
		max_width = 4
	}

	mut sb := strings.new_builder(500)
	sb.write_str('\n')
	sb.write_str('file ')
	sb.write_str(' '.repeat((max_width - 4)))
	sb.write_str(' % funcs')
	sb.write_str('   % blocks')
	sb.write_str('\n')
	sb.write_str('-'.repeat(max_width + 20))
	sb.write_str('\n')

	for file in r.files {
		path := r.format_path(file.path)
		sb.write_str(term.bold(path))
		sb.write_str(': ')
		sb.write_str(' '.repeat(max_width - path.len))
		sb.write_str(r.format_percent(file.funcs))
		sb.write_str('      ')
		sb.write_str(r.format_percent(file.blocks))
		sb.write_str('\n')
	}

	println(sb.str_view())
}

fn (r CoverageResult) format_percent(val f64) -> string {
	str := strconv.float_to_str(val * 100, 2, 512)

	mut formatted := str
	if val == 1.0 {
		formatted = term.green(formatted)
	}

	if val >= 0.8 {
		formatted = term.yellow(formatted)
	}

	if val <= 0.5 {
		formatted = term.bright_red(formatted)
	}

	padding := ' '.repeat(6 - str.len)
	return padding + formatted
}

fn (r CoverageResult) format_path(p string) -> string {
	if p.starts_with(r.testing_path) {
		mut rel := p[r.testing_path.len..]
		if rel.starts_with(fs.PATH_SEPARATOR_STRING) {
			rel = rel[1..]
		}
		return rel.clone()
	}

	return p
}

// FunctionCoverage represents the coverage information for a single function.
pub struct FunctionCoverage {
	// name is the name of the function.
	name string
	// blocks is the coverage information for each block in the function.
	blocks []CoverageBlock
}

// FileCoverage represents the coverage information for a single file.
// Each file contains coverage information for each block and each function.
pub struct FileCoverage {
	// path is the path to the file.
	path string
	// blocks is the coverage information for each block in the file.
	blocks []CoverageBlock
	// per_function is the coverage information for each function in the file.
	per_function map[string]FunctionCoverage
}

// Coverage represents the coverage information for the code.
pub struct Coverage {
	per_file map[string]FileCoverage
}

// parse parses the coverage mapping and returns the coverage information.
pub fn Coverage.parse(mapping string) -> Coverage {
	lines := mapping.split_into_lines()

	mut res := []CoverageBlock{cap: lines.len}

	for line in lines {
		idx, rest := line.split_by_first('=')
		file, rest2 := rest.split_by_first('&')
		func, rest3 := rest2.split_by_first(':')
		start, end := rest3.split_by_first(';')
		start_line, start_col := start.split_by_first(',')
		end_line, end_col := end.split_by_first(',')

		res.push(CoverageBlock{
			id: idx.i32()
			file: file
			func: backtrace.demangle(func)
			start_line: start_line.i32()
			start_col: start_col.i32()
			end_line: end_line.i32()
			end_col: end_col.i32()
		})
	}

	return Coverage.process_blocks(res)
}

fn Coverage.process_blocks(coverage_info []CoverageBlock) -> Coverage {
	mut per_file := map[string]FileCoverage{}
	for info in coverage_info {
		file := per_file.get_ptr_or_insert(info.file, FileCoverage{ path: info.file })
		file.blocks.push(info)
	}

	for file_name, file in per_file {
		mut per_function := map[string]FunctionCoverage{}
		for block in file.blocks {
			func := per_function.get_ptr_or_insert(block.func, FunctionCoverage{ name: block.func })
			func.blocks.push(block)
		}

		mut new_file := file
		new_file.per_function = per_function
		per_file[file_name] = new_file
	}

	return Coverage{ per_file: per_file }
}

// dump_coverage writes the coverage information to the given file.
#[skip_coverage]
pub fn dump_coverage(mode string, format string, testing_path string, path string) -> ?CoverageResult {
	if COUNT_BASIC_BLOCKS == 0 {
		println(term.yellow("warning:"), "no coverage samples were take, no coverage will be written")
		return none
	}

	if COVERAGE_MAPPING.len == 0 {
		println(term.yellow("warning:"), "coverage mapping is empty, no coverage will be written")
		return none
	}

	coverage_info := Coverage.parse(COVERAGE_MAPPING)
	coverage_res := CoverageResult.from(testing_path, coverage_info)

	if path.len == 0 {
		return coverage_res
	}

	mut sb := strings.new_builder(100)
	sb.write_str('mode: ')
	sb.write_str(mode)
	sb.write_str('\n')

	for file in coverage_info.per_file {
		for block in file.blocks {
			cov := spawn_coverage[block.id]

			sb.write_str(block.file)
			sb.write_str(':')
			sb.write_str(block.start_line.str())
			sb.write_str('.')
			sb.write_str(block.start_col.str())
			sb.write_str(',')
			sb.write_str(block.end_line.str())
			sb.write_str('.')
			sb.write_str(block.end_col.str())
			sb.write_str(' ')
			sb.write_str('1')
			sb.write_str(' ')
			sb.write_str(cov.str())
			sb.write_str('\n')
		}
	}
	fs.write_file(path, sb.str_view()) or {}

	return coverage_res
}
