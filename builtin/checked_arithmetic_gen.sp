module main

import fs
import strings

const HEADER = '// This file is generated by `checked_arithmetic_gen.sp`. Do not edit manually.
module builtin

import intrinsics

// This functions defined as macros in C, so types are not checked.
// Note that the last parameter defines the type for which the check will be performed,
// that is, if we pass the first two parameters `i32`, and the third pointer to `i8`, then
// the overflow check will be performed for `i8`, and not for `i32`.
extern {
    fn checked_add_with_overflow(a any, b any, c *mut any) -> bool
    fn checked_sub_with_overflow(a any, b any, c *mut any) -> bool
    fn checked_mul_with_overflow(a any, b any, c *mut any) -> bool
}
'

const PANIC_TEMPLATE = '
// panic_{name} is checked integer {action}. If `u` {op} `v` would overflow,
// function panics, otherwise it returns result of {action}.
#[track_caller]
pub fn (u {type}) panic_{name}(v {type}) -> {type} {
    mut res := 0 as {type}
    if intrinsics.unlikely(checked_{name}_with_overflow(u, v, &mut res)) {
        panic("`\${u} {op} \${v}` causes overflow of `{type}` type")
    }
    return res
}
'

const PANIC_DIV_TEMPLATE = '
// panic_{name} is checked integer {action}. If `v` is zero,
// function panics, otherwise it returns result of {action}.
#[track_caller]
pub fn (u {type}) panic_{name}(v {type}) -> {type} {
    if intrinsics.unlikely(v == 0) {
        panic("division by zero")
    }
    return u {op} v
}
'

const CHECKED_TEMPLATE = '
// checked_{name} is checked integer {action}. If `u` {op} `v` would overflow,
// function returns `none`, otherwise it returns result of {action}.
pub fn (u {type}) checked_{name}(v {type}) -> ?{type} {
    mut res := 0 as {type}
    if intrinsics.unlikely(checked_{name}_with_overflow(u, v, &mut res)) {
        return none
    }
    return res
}
'

const CHECKED_DIV_TEMPLATE = '
// checked_{name} is checked integer {action}. If `v` is zero,
// function returns `none`, otherwise it returns result of {action}.
pub fn (u {type}) checked_{name}(v {type}) -> ?{type} {
    if intrinsics.unlikely(v == 0) {
        return none
    }
    return u {op} v
}
'

const WRAPPING_TEMPLATE = '
// wrapping_{name} is checked integer {action}. If `u` {op} `v` would overflow,
// function returns result of {action} modulo maximum value of type `{type}`.
pub fn (u {type}) wrapping_{name}(v {type}) -> {type} {
    mut res := 0 as {type}
    checked_{name}_with_overflow(u, v, &mut res)
    return res
}
'

const PANIC_UNSIGNED_UNSIGNED_CAST_TEMPLATE = '
// panic_cast_to_{cast_type} is checked integer cast. If `u` is greater than maximum
// value of type `{cast_type}`, function panics, otherwise it returns result of cast.
#[track_caller]
pub fn (u {type}) panic_cast_to_{cast_type}() -> {cast_type} {
    if intrinsics.unlikely(u > {max_value} as {type}) {
        panic("overflow when casting \${u} to `{cast_type}`")
    }
    return u as {cast_type}
}
'

const PANIC_SIGNED_SIGNED_CAST_TEMPLATE = '
// panic_cast_to_{cast_type} is checked integer cast. If `u` is not in range of type
// `{cast_type}`, function panics, otherwise it returns result of cast.
#[track_caller]
pub fn (u {type}) panic_cast_to_{cast_type}() -> {cast_type} {
    if intrinsics.unlikely(u > {max_value} as {type} || u < {min_value} as {type}) {
        panic("overflow when casting \${u} to `{cast_type}`")
    }
    return u as {cast_type}
}
'

const PANIC_SIGNED_UNSIGNED_CAST_TEMPLATE = '
// panic_cast_to_{cast_type} is checked integer cast. If `u` is greater than maximum
// value of type `{cast_type}` or negative, function panics, otherwise it returns result of cast.
#[track_caller]
pub fn (u {type}) panic_cast_to_{cast_type}() -> {cast_type} {
    if intrinsics.unlikely(u < 0 || u as {cast_type} > {max_value} as {cast_type}) {
        if u < 0 {
            panic("overflow when casting \${u} to `{cast_type}`: casting a negative number to an unsigned type results in loss of information")
        }
        panic("overflow when casting \${u} to `{cast_type}`")
    }
    return u as {cast_type}
}
'

const PANIC_UNSIGNED_SIGNED_CAST_TEMPLATE = '
// panic_cast_to_{cast_type} is checked integer cast. If `u` is greater than maximum
// value of type `{cast_type}`, function panics, otherwise it returns result of cast.
#[track_caller]
pub fn (u {type}) panic_cast_to_{cast_type}() -> {cast_type} {
    if intrinsics.unlikely(u > {max_value} as {type}) {
        panic("overflow when casting \${u} to `{cast_type}`")
    }
    return u as {cast_type}
}
'

const CHECKED_UNSIGNED_UNSIGNED_CAST_TEMPLATE = '
// checked_cast_to_{cast_type} is checked integer cast. If `u` is greater than maximum
// value of type `{cast_type}`, function returns `none`, otherwise it returns result of cast.
#[track_caller]
pub fn (u {type}) checked_cast_to_{cast_type}() -> ?{cast_type} {
    if intrinsics.unlikely(u > {max_value} as {type}) {
        return none
    }
    return u as {cast_type}
}
'

const CHECKED_SIGNED_SIGNED_CAST_TEMPLATE = '
// checked_cast_to_{cast_type} is checked integer cast. If `u` is not in range of type
// `{cast_type}`, function returns `none`, otherwise it returns result of cast.
pub fn (u {type}) checked_cast_to_{cast_type}() -> ?{cast_type} {
    if intrinsics.unlikely(u > {max_value} as {type} || u < {min_value} as {type}) {
        return none
    }
    return u as {cast_type}
}
'

const CHECKED_SIGNED_UNSIGNED_CAST_TEMPLATE = '
// checked_cast_to_{cast_type} is checked integer cast. If `u` is greater than maximum
// value of type `{cast_type}` or negative, function returns `none`, otherwise it returns result of cast.
pub fn (u {type}) checked_cast_to_{cast_type}() -> ?{cast_type} {
    if intrinsics.unlikely(u < 0 || u as {cast_type} > {max_value} as {cast_type}) {
        return none
    }
    return u as {cast_type}
}
'

const CHECKED_UNSIGNED_SIGNED_CAST_TEMPLATE = '
// checked_cast_to_{cast_type} is checked integer cast. If `u` is greater than maximum
// value of type `{cast_type}`, function returns `none`, otherwise it returns result of cast.
pub fn (u {type}) checked_cast_to_{cast_type}() -> ?{cast_type} {
    if intrinsics.unlikely(u > {max_value} as {type}) {
        return none
    }
    return u as {cast_type}
}
'

const TEMPLATES = [
	PANIC_TEMPLATE,
	CHECKED_TEMPLATE,
	WRAPPING_TEMPLATE,
]

const DIV_TEMPLATES = [
	PANIC_DIV_TEMPLATE,
	CHECKED_DIV_TEMPLATE,
]

const UNSIGNED_UNSIGNED_CAST_TEMPLATES = [
	PANIC_UNSIGNED_UNSIGNED_CAST_TEMPLATE,
	CHECKED_UNSIGNED_UNSIGNED_CAST_TEMPLATE,
]

const UNSIGNED_SIGNED_CAST_TEMPLATES = [
	PANIC_UNSIGNED_SIGNED_CAST_TEMPLATE,
	CHECKED_UNSIGNED_SIGNED_CAST_TEMPLATE,
]

const SIGNED_UNSIGNED_CAST_TEMPLATES = [
	PANIC_SIGNED_UNSIGNED_CAST_TEMPLATE,
	CHECKED_SIGNED_UNSIGNED_CAST_TEMPLATE,
]

const SIGNED_SIGNED_CAST_TEMPLATES = [
	PANIC_SIGNED_SIGNED_CAST_TEMPLATE,
	CHECKED_SIGNED_SIGNED_CAST_TEMPLATE,
]

const TYPES = [
	'u8', 'u16', 'u32', 'usize', 'u64',
	'i8', 'i16', 'i32', 'isize', 'i64',
]

// NOTE: order of these values matters, because cast methods will be generated only from bigger to smaller types.
// And generator defines what size type has just looking on this array and on index of the element in it.
// So `u8` will be treated as smaller then `u16` because it has index 0 and `u16` has index 1.
const UNSIGNED_TYPES = [
	'u8', 'u16', 'u32', 'usize', 'u64',
]

// TODO: `rune` type must be in unsigned types array because it's naturally represented by `u32` with a custom max value.
// To do that, the following changes should be made:
// 1. the `rune` type's underlying type must be changed from `i32` to `u32`
// 2. the code that is responsible for casts must be improved, since currently casting from `u8` to `rune`
//    requires `panic_cast_to` method, which is not defined if we move `rune` type to unsigned types array to a correct
//    position. Also, method `panic_cast_to_u8` wouldn't be generated for `rune` type for some reason.
const SIGNED_TYPES = [
	'i8', 'i16', 'i32', 'isize', 'i64', 'rune',
]

struct Action {
	name   string
	typ    string
	action string
	op     string

	cast_type string
	min_value string
	max_value string
}

const ACTIONS = [
	Action{ name: 'add', action: 'addition', op: '+' },
	Action{ name: 'sub', action: 'subtraction', op: '-' },
	Action{ name: 'mul', action: 'multiplication', op: '*' },
]

const DIV_ACTIONS = [
	Action{ name: 'div', action: 'division', op: '/' },
	Action{ name: 'rem', action: 'remainder', op: '%' },
]

fn get_max_value_of_type(type_name string) -> string {
	return match type_name {
		'i8' => '127'
		'i16' => '32767'
		'i32' => '2147483647'
		'i64' => '9223372036854775807'
		'isize' => '9223372036854775807'
		'u8' => '255'
		'u16' => '65535'
		'u32' => '4294967295'
		'u64' => '18446744073709551615'
		'usize' => '18446744073709551615'
		'rune' => '0x10FFFF'
		else => panic('unknown type: ${type_name}')
	}
}

fn get_min_value_of_type(type_name string) -> string {
	return match type_name {
		'i8' => '-128'
		'i16' => '-32768'
		'i32' => '-2147483648'
		'i64' => '-9223372036854775808'
		'isize' => '-9223372036854775808'
		'u8', 'u16', 'u32', 'u64', 'usize', 'rune' => '0'
		else => panic('unknown type: ${type_name}')
	}
}

fn get_type_size(typ string) -> i32 {
	return match typ {
		'u8' => 1
		'u16' => 2
		'u32' => 4
		'u64' => 8
		'usize' => 8
		'i8' => 1
		'i16' => 2
		'i32' => 4
		'i64' => 8
		'isize' => 8
		'rune' => 4
		else => panic('unknown type: ${typ}')
	}
}

fn format(template string, action Action) -> string {
	return template.
		replace('{name}', action.name).
		replace('{type}', action.typ).
		replace('{action}', action.action).
		replace('{op}', action.op).
		replace('{cast_type}', action.cast_type).
		replace('{min_value}', action.min_value).
		replace('{max_value}', action.max_value)
}

fn main() {
	mut res := strings.new_builder(1000)
	res.write_str(HEADER)

	for tmpl in TEMPLATES {
		for typ in TYPES {
			for action in ACTIONS {
				typed_action := Action{ ...action, typ: typ }
				res.write_str(format(tmpl, typed_action))
			}
		}
	}

	for tmpl in DIV_TEMPLATES {
		for typ in TYPES {
			for action in DIV_ACTIONS {
				typed_action := Action{ ...action, typ: typ }
				res.write_str(format(tmpl, typed_action))
			}
		}
	}

	for tmpl in UNSIGNED_UNSIGNED_CAST_TEMPLATES {
		for i, typ in UNSIGNED_TYPES {
			for j, cast_type in UNSIGNED_TYPES {
				if typ == cast_type {
					continue
				}

				type_size := get_type_size(typ)
				cast_type_size := get_type_size(cast_type)

				if cast_type_size > type_size {
					// we don't need to check cast from smaller type to bigger
					continue
				}

				max_value := get_max_value_of_type(cast_type)

				typed_action := Action{ typ: typ, cast_type: cast_type, max_value: max_value }
				res.write_str(format(tmpl, typed_action))
			}
		}
	}

	for tmpl in SIGNED_SIGNED_CAST_TEMPLATES {
		for i, typ in SIGNED_TYPES {
			for j, cast_type in SIGNED_TYPES {
				if typ == cast_type {
					continue
				}

				type_size := get_type_size(typ)
				cast_type_size := get_type_size(cast_type)

				if cast_type_size > type_size {
					// we don't need to check cast from smaller type to bigger
					continue
				}

				max_value := get_max_value_of_type(cast_type)
				min_value := get_min_value_of_type(cast_type)

				typed_action := Action{
					typ: typ
					cast_type: cast_type
					max_value: max_value
					min_value: min_value
				}
				res.write_str(format(tmpl, typed_action))
			}
		}
	}

	for tmpl in SIGNED_UNSIGNED_CAST_TEMPLATES {
		for i, typ in SIGNED_TYPES {
			for j, cast_type in UNSIGNED_TYPES {
				if typ == cast_type {
					continue
				}
				max_value := get_max_value_of_type(cast_type)

				typed_action := Action{ typ: typ, cast_type: cast_type, max_value: max_value }
				res.write_str(format(tmpl, typed_action))
			}
		}
	}

	for tmpl in UNSIGNED_SIGNED_CAST_TEMPLATES {
		for i, typ in UNSIGNED_TYPES {
			for j, cast_type in SIGNED_TYPES {
				if typ == 'u8' && cast_type != 'i8' {
					// u8 can be casted to any signed type except i8 without overflow
					continue
				}

				if typ == 'u16' && cast_type !in ['i8', 'i16'] {
					// u16 can be casted to signed type except i8 and i16 without overflow
					continue
				}

				if typ == 'u32' && cast_type !in ['i8', 'i16', 'i32', 'rune'] {
					// u32 can be casted to signed type except i8, i16 and i32 without overflow
					continue
				}

				if (typ == 'u64' || typ == 'usize') && cast_type !in ['i8', 'i16', 'i32', 'rune', 'i64', 'isize'] {
					// u64 and usize can be casted to signed type except i8, i16, i32 and i64 without overflow
					continue
				}

				if typ == cast_type {
					continue
				}
				max_value := get_max_value_of_type(cast_type)

				typed_action := Action{ typ: typ, cast_type: cast_type, max_value: max_value }
				res.write_str(format(tmpl, typed_action))
			}
		}
	}

	path := './y/builtin/checked_arithmetic.sp'
	fs.write_file(path, res.str()) or {
		panic('failed to write file ${path}: ${err.msg()}')
	}
}
